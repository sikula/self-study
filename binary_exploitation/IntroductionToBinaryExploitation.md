Name  | Date  |  
--|---|--
Peter Vicherek  |  January 11, 2017
<h1><center>Introduction to Binary Exploitation and Debugging</center></h1>

---
## Goal
To learn the basics of Binary Exploitation by first understanding the internals of the system, specifically concepts such as how cpu instructions are executed and stored.  We should have the ability to understand the inner workings of a system, the common vulnerabilities found in programs, ways of exploiting those vulnerabilites, but most importantly why those exploits work.

---
## Preliminary Questions
- Who has access to memory?
  - Kernel space
  - User space
- Regions of Memory
  - Text
  - Data
  - Stack
- How is code executed?
  - What is the stack?
    - What are strack frames?
  - What is the heap?
  - What are registers?
  - What is the Global Offset Table?
- Types of exploits:
  - How do buffer overlfow exploits work?
  - How do stack overflow exploits work?
  - How do string-format work?
- Debugging
  - Tools:
    - strace,ltrace
    - objdump
    - gdb
    - nasm
  - How to control flow of execution?
  - How to change/set values?
---
> ## The CPU Internals

### 1. Registers
It would be very inefficient if the CPU has to access the RAM for every instruction it needed to execute, and thus, the CPU implements internal memory to store instructions.  These small chunks of internal memory are called **registers**. Depending on the architecture (e.g 32bit or 64bit systems), different registers may be present.

When the CPU wants to execute some sort of function, for example adding the value of `x` of `y`, it copies the value of `x` to one register and multiples it by the values of `y` in RAM (since `x` and `y` can't be directly manipulated from memory).  Furthere more, these registers can be used to store frequently used values or local variables used in a program.

So, what does a simple process, like `z = x + y` look like internally?

1. The current state of the machine is saved
2. Memory is allocated for `z` (depending on the data type)
3. Load the values of `x` and `y` into registers
4. Add `x` and `y` and store result in a register
5. Optional: copy result to the memory addresses allocated for `z`
6. Restore the machine state stored earlier
7. Return to the caller and send back `z` as the return value

> **NOTE:**  These registers can be controlled through the Assembly Language.

### 2. Types of Registers
There are various types of registers. For 32bit systems:

#### **General Purpose Registers:**
<center>name</center> | <center>32b | <center>16b | <center>8b | <center>description</center>
--|---|---|---|--
**accumulator** | `EAX` | `AX` | `AH, AL` | i/o, arithmetic, interrupt calls, etc
**base** | `EBX` | `BX` | `BH, BL` | base pointer for memory access, interrupt return values
**counter** | `ECX` | `CX` | `CH, CL` | loop counter and shifts
**data** | `EDX` | `DX` | `DH, DL` | i/o, arithmetic, some interrupt calls

#### **Indexes and Pointers:**
<center>name</center> | <center>32b | <center>16b |  <center>description</center>
--|---|---|---|--
destination index | `EDI` | `DI` | used for string, memory array copying and setting
source index | `ESI` | `SI` | used for string and memory array copying
stack base pointer | `EBP` | `BP` | holds the base address of the stack
stack pointer | `ESP` | `SP` | holds the top address of the stack
index pointer | `EIP` | `IP` | holds the offset of the next instruction, read-only
---
> ## **Process Memory Organization**

### 1. Memory Access
In order to attempt to prevent malicious behaviour occuring on a system, processes are assigned regions of memory which they are allowed to access, and should not be able to access memory outside of their allowed space.  This prevents **processA** from overwriting memory in **processB**, possibly leading to an exploit.  Let us examine these regions of memory in detail.

#### 1.1 Memory Addressing
On a 32bit system, 4GB of memory can be addressed and memory locations are addressed using the range (called **address space**) below:
```
0x00000000 - 0xffffffff
```
These addresses are important because they give us a way to directly access and view the contents of the memory at that location (address). This address space is divided into two main regions: high memory (HM) and low memory (LM).  

ADDRESS RANGE FOR 32bit SYSTEMS |
-

<center>region</center>  |  <center>address range</center> |  <center>size</center>
--|---|--
<center>**HM**</center>  | `0x00000000 - 0xbfffffff`  |  `3221225472`
<center>**LM**</center> | `0xc0000000 - 0xffffffff`  | `1073741824`

Out of the 1GB of low memory, 128MB is reserve for high memory access.  Every kernel process can access the user space range, if it wishes. In this case, the kernel maps and address from user space (HM) to kernel-space (LM) in the 128MB reserved space.

#### 1.2 Kernel-space (LM)
The low memory, also known as the **kernel space** is a special region of memory reserved for the kernel to perform any necessary operations, for example using the `hlt` instruction to temporarily halt the CPU.

#### 1.3 User-space (HM)
This high memory, also known as **user space** is the region of memory used my normal processes and applications to run.  Processes in user space can on access a small part of the kernel through an interface exposes by the kernel, called **system calls**.

It is important to remember that code executing in kernel-space runs full privileges and should be able to access any valid memory address on the system.  On the other hand, user-space code is limited to the region of memory assigned by the kernel.

### 2. Process Layout in Memory
A process are divided into a few main regions which hold data needed for the process to excute successfully.

Text  | <-- Lower Memory Addresses
--|--
**Data**  |  
**Stack**  | **<-- Higher Memory Addresses**

#### 2.1 Text
This region corresponds to the `.text` section of an executable program. This data is fixed by the executing program and marked read-only and any attempts made to write to it will result in segmentation violation.

Take, for example this simple C program.
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char*argv[]) {
  printf("Hello World\n");
}
```

We can compile it using gcc:
`gcc -o helloworld -m32 helloworld.c`

And then dump the .text section
```
$ objdump -D -M intel --section ".text" helloworld
Disassembly of section .text:

08048310 <_start>:
 8048310:       31 ed                   xor    ebp,ebp
 8048312:       5e                      pop    esi
 8048313:       89 e1                   mov    ecx,esp
 8048315:       83 e4 f0                and    esp,0xfffffff0
 8048318:       50                      push   eax
 8048319:       54                      push   esp
 804831a:       52                      push   edx
 804831b:       68 a0 84 04 08          push   0x80484a0
 8048320:       68 40 84 04 08          push   0x8048440
 8048325:       51                      push   ecx
 ...
```
#### 2.2 Data
The data section (sometimes called the **data segment**) contains intialized static variables (global or static local variables).

#### 2.3 Stack
The stack is one of the most important concepts to understand and we will examine it further in the next section.

#### 2.4 Heap
The heap is used for dynamically allocating memory, managed either by software libraries or through the operating system.  Heaps are used for variable-sized block of memory (think `malloc`)

#### 2.5 How Data Appears in Memory
Imagine we had a string, like "BINARY" stored in memory.  How would it looks like?  That depends on the **endianess** of the system.  Endianess describes at which location the most significant bit (MSB) or the least significants bit (LSB) is stored.

There are two main ways that the data can be stored, **big-endian** and **little-endian**.  Since most data in the x86 architecture is in little-endian, we will examine this form.

##### Little-endian
As we know, on a 32bit system, each memory address can hold 32 bits (or 4-bytes).  When data is stored in memory, it stored in increasing address range, meaning from the lowest available memory address to the highest memory address.

In little-endian format, the least significant bit is stored at the first location, and the most significat bit is stored at the last position.

Lets say we wanted to store the string "BINARY" in memory.  We know that each character takes up one byte, so we can store "BINA" at one address and "RY" at the next address.

```
increasing memory range -------->
+---------------+---------------+
|   0xffffff01  |   0xffffff02  |    Memory Address
+---+---+---+---+---+---+---+---+
| A | N | I | B | 0 | 0 | Y | R |    Data
+---+---+---+---+---+---+---+---+
| 1 | 2 | 3 | 4 | 1 | 2 | 3 | 4 |    Position
+---+---+---+---+---+---+---+---+
|     32bits    |    32bits     |
+---------------+---------------+
```
Since the data is stored in little-endian, we read the data from the lowest memory address to the highest memory address, and the data at each address from right to left.

> **NOTE:** The `0` represent a NUL value (hexidecimal 0x0), which is ignored when read from memory.

---
> ## **Anatomy of the Stack**

### 1. What is the stack?
The stack is an abstract data type used in computer science.  You can think of the stack as a short-term memory region which hold the values which cannot be stored in registers.  Each stack represents the current program.

The stack adheres to the **Last In First Out** (LIFO) property, meaning, the last object placed on the stack will be the first object removed from the stack.

There are several operations which can be performed to manipulate the stack, but the most important ones are `PUSH` (which adds an element to the top of the stack) and `POP` (which removes an element from the top of the stack).

Imagine you wanted to push the string "BINARY" onto the stack.  How would we achieve this?  At first, we might think we can just `PUSH` the characters in order.  But lets see what happens when we do this.

```
PUSH B
PUSH I
PUSH N
PUSH A
PUSH R
PUSH Y
```
Our stack now looks like this
```
+------------+---+ <-- top of stack
| byte [1]   | Y |
+------------+---+
| byte [2]   | R |
+------------+---+
| byte [3]   | A |
+------------+---+
| byte [4]   | N |
+------------+---+
| byte [5]   | I |
+------------+---+
| byte [6]|  | B |
+------------+---+ <-- bottom of stack
```

Now, if we were to then `POP` each element off the stack and reassembly the string we would end up with "YRANIB".


Uh oh! Thats not what we wanted, what happened?  Due to the LIFO property, in order to get the correct string back, we would need to push the string in reverse order so when the characters are popped off the stack, we get our desired string.

```
PUSH Y
PUSH R
PUSH A
PUSH N
PUSH I
PUSH B
```
Our stack now looks like this:

```
+------------+---+ <-- top of stack
| byte [1]   | B |
+------------+---+
| byte [2]   | I |
+------------+---+
| byte [3]   | N |
+------------+---+
| byte [4]   | A |
+------------+---+
| byte [5]   | R |
+------------+---+
| byte [6]|  | Y |
+------------+---+ <-- bottom of stack
```

<br />

So, how would this look in memory?
```
+---------------+---------------+
|  0xffffff01   |  0xffffff02   |
+---+---+---+---+---+---+---+---+
| B | I | N | A | R | Y | 0 | 0 |
+---+---+---+---+---+---+---+---+
```

> **NOTE**: This is a very important concept to understand so that when we attempt to manipulate the stack, we are providing the correct values in the correct order to obtain our desired result.  If we push the instructions in the wrong order, our code will not execute as intended.

### 2. What is the stack used for?
Programs have structures which control the execution of a program, the most important structure being the **function** (also known as a **procedure**).  A function alters the flow of control, but upon completion, returns control to the statement following the call.

The stack is responsible for:
* dynamically allocate the local variables used in functions
* to pass parameters to functions
* to return values from functions
* to store temporarily saved register values

### 3. Stack Internals
So far we know that the stack holds certain values needed for a program, or part of a program to execute.  It can also store values that cannot be stored in registers. Furthermore, we know that instructions are POPPED and PUSHED off the stack. One question still remains though.  If all the instructions required to execute a program are pushed onto the stack, how do we know what data belongs to what function call?

For each function call, there is a section in the stack reserved for the function.  This reserved space is called the **stack frame**.  The stack contains the parameters to the function, its local variables, and the data necesarry to recover the previous stack frame. Multiple stack frames in sequence is called a **call stack**.


#### 3.1 How is a function called?
Before a function is called, a series of events takes place:
1. The local variables and temporiries are pushed onto the stack.
2. The parameters of the function being called are pushed on the stack.
3. The PC (Program Counter) is ushed onto the stack (usually identified by a `call` instruction).  If the PC resides on the stack, it is referredd to as the **return address**

These steps are taking to ensure the program knows how to continue, after the called function has been executed.

When a function begins executing, another series of events takes place:
1.  The current FP (Frame Pointer, also known as Base Pointer) is pushed onto the stack.
2. The SP (Stack Pointer) is copied to the FP.
3. SP is adjusted to "make room" for local variables on the stack.

This process is referred to as the **function prologue**.

When a function completes its execution, it reverses the steps, called the **function epilogue**
1. The SP is restored and the space for local variables is deallocated.
2. The FP is restored and the previous frame is restored
3. The PC is restored (identified by the `ret` instruction)

When execution is restored to the original caller, the process is as follows:
1. The parameters of the function that was called are removed from the stack.
2. The local variables are popped off the stack, thus restoring them.

#### 3.2 Stack Frame Layout


---
> ## Introduction to Debugging with GDB

### 1. Intel versus AT&T Syntax

### 2. Disassemblying

### 3. Viewing Registers

### 4. Viewing Frames

### 5. Viewing Memory

### 6. Editing Values in Memory

---
> ## Solution

```
# ; buffer overflow

# ; buffer overflow

# ; buffer overflow

# ; format string : write memory exploit
$ ./pwnme $(python -c 'print "\xff\xd6\xff\xff"')%1331x%5\$n
```


---
## Reading Material
1. [Smashing the Stack for Fun and Profit](http://inst.eecs.berkeley.edu/~cs161/fa08/papers/stack_smashing.pdf)
2. Reversing: Secrets of Reverse Engineering **(ISBN-10: 0-7645-7481-7)**
3. [Shellcode Injection](https://dhavalkapil.com/blogs/Shellcode-Injection/)
4. A Guide to Kernel Exploitation **(ISBN 978-1-59749-486-1)**
5. [Linux ExploitDev](http://www.fuzzysecurity.com/tutorials/expDev/10.html)
6. [Difference Between Kernel and User space](https://unix.stackexchange.com/questions/87625/what-is-difference-between-user-space-and-kernel-space)
7. [High and Low Memory](https://unix.stackexchange.com/questions/4929/what-are-high-memory-and-low-memory-on-linux/5151#5151)
8. [Stack Analysis with GDB](http://resources.infosecinstitute.com/stack-analysis-with-gdb/)
9. [Format String Vulns in Gory Detail](https://blog.skullsecurity.org/2015/defcon-quals-babyecho-format-string-vulns-in-gory-detail)
10. [Citizendium - Stack Frame](http://en.citizendium.org/wiki/Stack_frame)
